/**
 * @file operaciones_aritmeticas_seguras.c
 * @brief Implementaci√≥n de operaciones aritm√©ticas seguras con detecci√≥n de overflow
 * @details Implementa funciones que detectan y previenen overflow/underflow
 *          aritm√©tico, un problema cr√≠tico de seguridad en programas C.
 */

#include "../include/operaciones_aritmeticas_seguras.h"
#include <stdlib.h>
#include <string.h>

// =============================================================================
// CONSTANTES Y VALORES DE PRUEBA
// =============================================================================

const int VALORES_PRUEBA_OVERFLOW[] = {
    INT_MAX, INT_MAX - 1, INT_MAX - 10,
    INT_MIN, INT_MIN + 1, INT_MIN + 10,
    0, 1, -1, 10, -10, 1000, -1000
};

const size_t NUM_VALORES_PRUEBA = sizeof(VALORES_PRUEBA_OVERFLOW) / sizeof(VALORES_PRUEBA_OVERFLOW[0]);

const int CASOS_LIMITE_INT[] = {
    INT_MAX, INT_MIN, INT_MAX - 1, INT_MIN + 1,
    INT_MAX / 2, INT_MIN / 2, 0, 1, -1
};

const size_t NUM_CASOS_LIMITE = sizeof(CASOS_LIMITE_INT) / sizeof(CASOS_LIMITE_INT[0]);

// =============================================================================
// OPERACIONES B√ÅSICAS SEGURAS PARA INT
// =============================================================================

resultado_aritmetica_t suma_segura(int a, int b, int* resultado) {
    if (resultado == NULL) {
        return ARITMETICA_ERROR_PARAMETRO;
    }
    
    // Verificar overflow positivo: b > 0 && a > INT_MAX - b
    if (b > 0 && a > INT_MAX - b) {
        return ARITMETICA_OVERFLOW;
    }
    
    // Verificar underflow (overflow negativo): b < 0 && a < INT_MIN - b
    if (b < 0 && a < INT_MIN - b) {
        return ARITMETICA_UNDERFLOW;
    }
    
    // Operaci√≥n segura
    *resultado = a + b;
    return ARITMETICA_EXITOSA;
}

resultado_aritmetica_t resta_segura(int a, int b, int* resultado) {
    if (resultado == NULL) {
        return ARITMETICA_ERROR_PARAMETRO;
    }
    
    // Verificar overflow: b < 0 && a > INT_MAX + b
    // Equivalente a: a - b > INT_MAX
    if (b < 0 && a > INT_MAX + b) {
        return ARITMETICA_OVERFLOW;
    }
    
    // Verificar underflow: b > 0 && a < INT_MIN + b
    // Equivalente a: a - b < INT_MIN
    if (b > 0 && a < INT_MIN + b) {
        return ARITMETICA_UNDERFLOW;
    }
    
    // Operaci√≥n segura
    *resultado = a - b;
    return ARITMETICA_EXITOSA;
}

resultado_aritmetica_t multiplicacion_segura(int a, int b, int* resultado) {
    if (resultado == NULL) {
        return ARITMETICA_ERROR_PARAMETRO;
    }
    
    // Casos especiales que no pueden causar overflow
    if (a == 0 || b == 0) {
        *resultado = 0;
        return ARITMETICA_EXITOSA;
    }
    
    if (a == 1) {
        *resultado = b;
        return ARITMETICA_EXITOSA;
    }
    
    if (b == 1) {
        *resultado = a;
        return ARITMETICA_EXITOSA;
    }
    
    // Caso especial: -1 * -1 = 1 (seguro)
    if (a == -1 && b == -1) {
        *resultado = 1;
        return ARITMETICA_EXITOSA;
    }
    
    // Caso especial problem√°tico: INT_MIN * -1 = overflow
    if ((a == INT_MIN && b == -1) || (a == -1 && b == INT_MIN)) {
        return ARITMETICA_OVERFLOW;
    }
    
    // Para otros casos, usar divisi√≥n para verificar overflow
    // Si a * b causar√≠a overflow, entonces |a| > INT_MAX / |b|
    
    // Calcular valores absolutos de forma segura
    int abs_a = (a == INT_MIN) ? INT_MAX : abs(a);
    int abs_b = (b == INT_MIN) ? INT_MAX : abs(b);
    
    // Verificar si el resultado cabr√≠a en un int
    if (abs_a > INT_MAX / abs_b) {
        return (a > 0) == (b > 0) ? ARITMETICA_OVERFLOW : ARITMETICA_UNDERFLOW;
    }
    
    // Operaci√≥n segura
    *resultado = a * b;
    return ARITMETICA_EXITOSA;
}

resultado_aritmetica_t division_segura(int a, int b, int* resultado) {
    if (resultado == NULL) {
        return ARITMETICA_ERROR_PARAMETRO;
    }
    
    // Verificar divisi√≥n por cero
    if (b == 0) {
        return ARITMETICA_DIVISION_CERO;
    }
    
    // Caso especial: INT_MIN / -1 = overflow (dar√≠a INT_MAX + 1)
    if (a == INT_MIN && b == -1) {
        return ARITMETICA_OVERFLOW;
    }
    
    // Operaci√≥n segura
    *resultado = a / b;
    return ARITMETICA_EXITOSA;
}

resultado_aritmetica_t modulo_seguro(int a, int b, int* resultado) {
    if (resultado == NULL) {
        return ARITMETICA_ERROR_PARAMETRO;
    }
    
    // Verificar divisi√≥n por cero
    if (b == 0) {
        return ARITMETICA_DIVISION_CERO;
    }
    
    // El m√≥dulo no puede causar overflow, pero verificamos el caso especial
    // INT_MIN % -1 en algunos sistemas puede ser problem√°tico
    if (a == INT_MIN && b == -1) {
        *resultado = 0;  // Matem√°ticamente correcto
        return ARITMETICA_EXITOSA;
    }
    
    // Operaci√≥n segura
    *resultado = a % b;
    return ARITMETICA_EXITOSA;
}

// =============================================================================
// OPERACIONES SEGURAS PARA OTROS TIPOS
// =============================================================================

resultado_aritmetica_t suma_segura_long(long long a, long long b, long long* resultado) {
    if (resultado == NULL) {
        return ARITMETICA_ERROR_PARAMETRO;
    }
    
    // Verificar overflow: b > 0 && a > LLONG_MAX - b
    if (b > 0 && a > LLONG_MAX - b) {
        return ARITMETICA_OVERFLOW;
    }
    
    // Verificar underflow: b < 0 && a < LLONG_MIN - b
    if (b < 0 && a < LLONG_MIN - b) {
        return ARITMETICA_UNDERFLOW;
    }
    
    *resultado = a + b;
    return ARITMETICA_EXITOSA;
}

resultado_aritmetica_t suma_segura_uint(unsigned int a, unsigned int b, unsigned int* resultado) {
    if (resultado == NULL) {
        return ARITMETICA_ERROR_PARAMETRO;
    }
    
    // Para unsigned, solo verificar overflow (no underflow en suma)
    if (a > UINT_MAX - b) {
        return ARITMETICA_OVERFLOW;
    }
    
    *resultado = a + b;
    return ARITMETICA_EXITOSA;
}

resultado_aritmetica_t suma_segura_size_t(size_t a, size_t b, size_t* resultado) {
    if (resultado == NULL) {
        return ARITMETICA_ERROR_PARAMETRO;
    }
    
    // Verificar overflow en size_t
    if (a > SIZE_MAX - b) {
        return ARITMETICA_OVERFLOW;
    }
    
    *resultado = a + b;
    return ARITMETICA_EXITOSA;
}

// =============================================================================
// FUNCIONES DE VALIDACI√ìN Y VERIFICACI√ìN
// =============================================================================

bool verificar_suma_segura(int a, int b) {
    return !((b > 0 && a > INT_MAX - b) || (b < 0 && a < INT_MIN - b));
}

bool verificar_multiplicacion_segura(int a, int b) {
    int dummy;
    return multiplicacion_segura(a, b, &dummy) == ARITMETICA_EXITOSA;
}

bool calcular_rango_suma_segura(int base, int* min_suma, int* max_suma) {
    if (min_suma == NULL || max_suma == NULL) {
        return false;
    }
    
    // Calcular el rango seguro para sumar a 'base'
    *max_suma = INT_MAX - base;  // m√°ximo valor que se puede sumar
    *min_suma = INT_MIN - base;  // m√≠nimo valor que se puede sumar
    
    return true;
}

// =============================================================================
// FUNCIONES DE DEMOSTRACI√ìN
// =============================================================================

void demostrar_vulnerabilidades_overflow(void) {
    putchar('\n');
    for (int i = 0; i < 70; i++) putchar('=');
    putchar('\n');
    printf("üö® DEMOSTRACI√ìN: VULNERABILIDADES DE OVERFLOW ARITM√âTICO\n");
    for (int i = 0; i < 70; i++) putchar('=');
    putchar('\n');
    
    printf("\nüí£ PROBLEMA 1: Overflow silencioso en validaci√≥n de tama√±o\n");
    printf("C√≥digo vulnerable t√≠pico:\n");
    printf("```c\n");
    printf("if (size + offset < buffer_size) {\n");
    printf("    // ¬°VULNERABLE! Si size + offset causa overflow,\n");
    printf("    // el resultado puede ser negativo y pasar la validaci√≥n\n");
    printf("}\n```\n");
    
    // Demostraci√≥n pr√°ctica
    unsigned int size = UINT_MAX - 10;
    unsigned int offset = 20;
    unsigned int buffer_size = 1000;
    
    printf("\nEjemplo pr√°ctico:\n");
    printf("   size = %u (muy grande)\n", size);
    printf("   offset = %u\n", offset);
    printf("   buffer_size = %u\n", buffer_size);
    
    // Aritm√©tica insegura (demuestra el problema)
    unsigned int suma_insegura = size + offset;  // ¬°Overflow!
    printf("\n‚ùå Aritm√©tica insegura:\n");
    printf("   size + offset = %u (¬°overflow!)\n", suma_insegura);
    printf("   %u < %u? %s\n", suma_insegura, buffer_size, 
           (suma_insegura < buffer_size) ? "S√ç (¬°PELIGRO!)" : "NO");
    
    // Aritm√©tica segura
    unsigned int suma_segura_result;
    resultado_aritmetica_t resultado = suma_segura_uint(size, offset, &suma_segura_result);
    printf("\n‚úÖ Aritm√©tica segura:\n");
    printf("   resultado: %s\n", resultado_aritmetica_a_string(resultado));
    if (resultado == ARITMETICA_OVERFLOW) {
        printf("   ¬°Overflow detectado y prevenci√≥n activada!\n");
    }
    
    printf("\nüí£ PROBLEMA 2: Overflow en c√°lculo de memoria\n");
    int num_elementos = 1000000;
    int tama√±o_elemento = 3000;
    
    printf("Calculando memoria necesaria:\n");
    printf("   elementos = %d\n", num_elementos);
    printf("   tama√±o por elemento = %d bytes\n", tama√±o_elemento);
    
    // Inseguro
    int memoria_insegura = num_elementos * tama√±o_elemento;  // ¬°Overflow!
    printf("\n‚ùå C√°lculo inseguro: %d * %d = %d\n", 
           num_elementos, tama√±o_elemento, memoria_insegura);
    printf("   ¬øEs realista? %s\n", 
           (memoria_insegura > 0 && memoria_insegura < 100000) ? "S√ç (¬°ERROR!)" : "NO");
    
    // Seguro
    int memoria_segura_result;
    resultado = multiplicacion_segura(num_elementos, tama√±o_elemento, &memoria_segura_result);
    printf("\n‚úÖ C√°lculo seguro: %s\n", resultado_aritmetica_a_string(resultado));
}

void demostrar_operaciones_seguras(void) {
    putchar('\n');
    for (int i = 0; i < 70; i++) putchar('=');
    putchar('\n');
    printf("üõ°Ô∏è DEMOSTRACI√ìN: OPERACIONES ARITM√âTICAS SEGURAS\n");
    for (int i = 0; i < 70; i++) putchar('=');
    putchar('\n');
    
    printf("\nüß™ Pruebas con valores l√≠mite:\n");
    
    struct {
        int a, b;
        const char* descripcion;
    } casos_prueba[] = {
        {INT_MAX, 1, "INT_MAX + 1 (overflow)"},
        {INT_MIN, -1, "INT_MIN - 1 (underflow)"},
        {INT_MAX, -1, "INT_MAX - 1 (seguro)"},
        {INT_MIN, 1, "INT_MIN + 1 (seguro)"},
        {INT_MAX / 2, INT_MAX / 2, "Suma grande pero segura"},
        {INT_MIN / 2, INT_MIN / 2, "Suma negativa grande"}
    };
    
    size_t num_casos = sizeof(casos_prueba) / sizeof(casos_prueba[0]);
    
    for (size_t i = 0; i < num_casos; i++) {
        printf("\nüìä Caso %zu: %s\n", i + 1, casos_prueba[i].descripcion);
        printf("   Operaci√≥n: %d + %d\n", casos_prueba[i].a, casos_prueba[i].b);
        
        int resultado_suma;
        resultado_aritmetica_t resultado = suma_segura(casos_prueba[i].a, casos_prueba[i].b, &resultado_suma);
        
        printf("   Estado: %s\n", resultado_aritmetica_a_string(resultado));
        if (resultado == ARITMETICA_EXITOSA) {
            printf("   Resultado: %d\n", resultado_suma);
        } else {
            printf("   ‚ö†Ô∏è  Operaci√≥n insegura detectada y bloqueada\n");
        }
    }
    
    printf("\nüî¢ Pruebas de multiplicaci√≥n:\n");
    
    struct {
        int a, b;
        const char* descripcion;
    } casos_mult[] = {
        {INT_MAX, 2, "INT_MAX * 2 (overflow)"},
        {INT_MIN, -1, "INT_MIN * -1 (overflow especial)"},
        {46341, 46341, "L√≠mite aproximado de sqrt(INT_MAX)"},
        {1000, 1000, "Multiplicaci√≥n segura"},
        {0, INT_MAX, "Multiplicaci√≥n por cero"}
    };
    
    size_t num_casos_mult = sizeof(casos_mult) / sizeof(casos_mult[0]);
    
    for (size_t i = 0; i < num_casos_mult; i++) {
        printf("\nüìä Caso %zu: %s\n", i + 1, casos_mult[i].descripcion);
        printf("   Operaci√≥n: %d * %d\n", casos_mult[i].a, casos_mult[i].b);
        
        int resultado_mult;
        resultado_aritmetica_t resultado = multiplicacion_segura(casos_mult[i].a, casos_mult[i].b, &resultado_mult);
        
        printf("   Estado: %s\n", resultado_aritmetica_a_string(resultado));
        if (resultado == ARITMETICA_EXITOSA) {
            printf("   Resultado: %d\n", resultado_mult);
        }
    }
}

void ejecutar_pruebas_casos_limite(estadisticas_aritmetica_t* stats) {
    if (stats) {
        inicializar_estadisticas_aritmetica(stats);
    }
    
    putchar('\n');
    for (int i = 0; i < 70; i++) putchar('=');
    putchar('\n');
    printf("üß™ PRUEBAS EXHAUSTIVAS CON CASOS L√çMITE\n");
    for (int i = 0; i < 70; i++) putchar('=');
    putchar('\n');
    
    printf("\nüìã Ejecutando %zu √ó %zu = %zu combinaciones de prueba...\n", 
           NUM_CASOS_LIMITE, NUM_CASOS_LIMITE, NUM_CASOS_LIMITE * NUM_CASOS_LIMITE);
    
    size_t pruebas_exitosas = 0;
    size_t overflows_detectados = 0;
    size_t underflows_detectados = 0;
    
    for (size_t i = 0; i < NUM_CASOS_LIMITE; i++) {
        for (size_t j = 0; j < NUM_CASOS_LIMITE; j++) {
            int a = CASOS_LIMITE_INT[i];
            int b = CASOS_LIMITE_INT[j];
            int resultado;
            
            resultado_aritmetica_t estado = suma_segura(a, b, &resultado);
            
            if (stats) {
                actualizar_estadisticas_aritmetica(stats, estado);
            }
            
            switch (estado) {
                case ARITMETICA_EXITOSA:
                    pruebas_exitosas++;
                    break;
                case ARITMETICA_OVERFLOW:
                    overflows_detectados++;
                    printf("   ‚ö†Ô∏è  Overflow: %d + %d\n", a, b);
                    break;
                case ARITMETICA_UNDERFLOW:
                    underflows_detectados++;
                    printf("   ‚ö†Ô∏è  Underflow: %d + %d\n", a, b);
                    break;
                default:
                    break;
            }
        }
    }
    
    printf("\nüìà Resultados de las pruebas:\n");
    printf("   ‚úÖ Operaciones exitosas: %zu\n", pruebas_exitosas);
    printf("   üî∫ Overflows detectados: %zu\n", overflows_detectados);
    printf("   üîª Underflows detectados: %zu\n", underflows_detectados);
    printf("   üìä Total de pruebas: %zu\n", NUM_CASOS_LIMITE * NUM_CASOS_LIMITE);
}

void comparacion_aritmetica_normal_vs_segura(void) {
    putchar('\n');
    for (int i = 0; i < 70; i++) putchar('=');
    putchar('\n');
    printf("‚öñÔ∏è COMPARACI√ìN: ARITM√âTICA NORMAL vs SEGURA\n");
    for (int i = 0; i < 70; i++) putchar('=');
    putchar('\n');
    
    printf("\nüìã Tabla comparativa:\n");
    printf("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n");
    printf("‚îÇ Caracter√≠stica      ‚îÇ Aritm√©tica Normal   ‚îÇ Aritm√©tica Segura   ‚îÇ\n");
    printf("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n");
    printf("‚îÇ Detecci√≥n overflow  ‚îÇ ‚ùå NO               ‚îÇ ‚úÖ S√ç               ‚îÇ\n");
    printf("‚îÇ Comportamiento def. ‚îÇ ‚ùå INDEFINIDO       ‚îÇ ‚úÖ PREDECIBLE       ‚îÇ\n");
    printf("‚îÇ Feedback de errores ‚îÇ ‚ùå SILENCIOSO       ‚îÇ ‚úÖ EXPL√çCITO        ‚îÇ\n");
    printf("‚îÇ Seguridad           ‚îÇ ‚ùå VULNERABLE       ‚îÇ ‚úÖ SEGURO           ‚îÇ\n");
    printf("‚îÇ Rendimiento         ‚îÇ ‚úÖ R√ÅPIDO           ‚îÇ ‚ö†Ô∏è  LIGERO OVERHEAD ‚îÇ\n");
    printf("‚îÇ Uso en producci√≥n   ‚îÇ ‚ùå PELIGROSO        ‚îÇ ‚úÖ RECOMENDADO      ‚îÇ\n");
    printf("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    
    printf("\nüß™ Ejemplo lado a lado:\n");
    
    int a = INT_MAX;
    int b = 1;
    
    printf("\nOperaci√≥n: %d + %d\n", a, b);
    
    // Aritm√©tica normal (insegura)
    printf("\n‚ùå Aritm√©tica normal:\n");
    int resultado_normal = a + b;  // ¬°Comportamiento indefinido!
    printf("   resultado = %d\n", resultado_normal);
    printf("   ¬øEs correcto? %s\n", 
           (resultado_normal > a) ? "S√ç" : "NO (¬°overflow silencioso!)");
    
    // Aritm√©tica segura
    printf("\n‚úÖ Aritm√©tica segura:\n");
    int resultado_seguro;
    resultado_aritmetica_t estado = suma_segura(a, b, &resultado_seguro);
    printf("   estado = %s\n", resultado_aritmetica_a_string(estado));
    printf("   acci√≥n = %s\n", 
           (estado == ARITMETICA_OVERFLOW) ? "Overflow detectado, operaci√≥n bloqueada" : "Resultado v√°lido");
}

void demostracion_completa_aritmetica_segura(void) {
    printf("\n" "üî¢ EJERCICIO 096: OPERACIONES ARITM√âTICAS SEGURAS" "\n");
    for (int i = 0; i < 70; i++) putchar('=');
    putchar('\n');
    
    printf("\nüìö OBJETIVOS DE APRENDIZAJE:\n");
    printf("   ‚Ä¢ Entender los riesgos de overflow aritm√©tico\n");
    printf("   ‚Ä¢ Aprender a detectar overflow antes de que ocurra\n");
    printf("   ‚Ä¢ Implementar operaciones aritm√©ticas seguras\n");
    printf("   ‚Ä¢ Prevenir vulnerabilidades relacionadas con enteros\n");
    
    printf("\n‚ö†Ô∏è  CONCEPTOS CLAVE:\n");
    printf("   ‚Ä¢ Integer Overflow: Resultado excede capacidad del tipo\n");
    printf("   ‚Ä¢ Comportamiento Indefinido: C no define qu√© pasa en overflow\n");
    printf("   ‚Ä¢ Verificaci√≥n Preventiva: Comprobar l√≠mites antes de operar\n");
    printf("   ‚Ä¢ Validaci√≥n de Entrada: Verificar rangos v√°lidos\n");
    
    imprimir_limites_tipos_datos();
    
    printf("\n¬øDesea ejecutar la demostraci√≥n completa? (s/n): ");
    char respuesta;
    scanf(" %c", &respuesta);
    
    if (respuesta == 's' || respuesta == 'S') {
        demostrar_vulnerabilidades_overflow();
        
        printf("\nPresione Enter para continuar...");
        getchar();
        getchar();
        
        demostrar_operaciones_seguras();
        
        printf("\nPresione Enter para continuar...");
        getchar();
        
        estadisticas_aritmetica_t stats;
        ejecutar_pruebas_casos_limite(&stats);
        
        printf("\nPresione Enter para continuar...");
        getchar();
        
        comparacion_aritmetica_normal_vs_segura();
        
        printf("\nüéì LECCIONES APRENDIDAS:\n");
        printf("   ‚úÖ Overflow aritm√©tico puede crear vulnerabilidades serias\n");
        printf("   ‚úÖ Siempre verificar l√≠mites antes de operaciones cr√≠ticas\n");
        printf("   ‚úÖ Usar funciones seguras en c√≥digo de producci√≥n\n");
        printf("   ‚úÖ El overhead de verificaci√≥n vale la pena por la seguridad\n");
        
        printf("\nüí° MEJORES PR√ÅCTICAS:\n");
        printf("   ‚Ä¢ Verificar l√≠mites antes de operaciones aritm√©ticas\n");
        printf("   ‚Ä¢ Usar tipos de datos apropiados (unsigned para tama√±os)\n");
        printf("   ‚Ä¢ Implementar manejo de errores para overflow\n");
        printf("   ‚Ä¢ Probar con valores l√≠mite durante desarrollo\n");
        
        printf("\nüìä Estad√≠sticas finales:\n");
        imprimir_estadisticas_aritmetica(&stats);
    }
}

// =============================================================================
// FUNCIONES AUXILIARES
// =============================================================================

const char* resultado_aritmetica_a_string(resultado_aritmetica_t resultado) {
    switch (resultado) {
        case ARITMETICA_EXITOSA:
            return "Operaci√≥n exitosa";
        case ARITMETICA_OVERFLOW:
            return "Overflow detectado";
        case ARITMETICA_UNDERFLOW:
            return "Underflow detectado";
        case ARITMETICA_DIVISION_CERO:
            return "Divisi√≥n por cero";
        case ARITMETICA_ERROR_PARAMETRO:
            return "Error en par√°metros";
        default:
            return "Resultado desconocido";
    }
}

void inicializar_estadisticas_aritmetica(estadisticas_aritmetica_t* stats) {
    if (stats == NULL) {
        return;
    }
    
    stats->operaciones_exitosas = 0;
    stats->overflows_detectados = 0;
    stats->underflows_detectados = 0;
    stats->divisiones_cero = 0;
    stats->errores_parametro = 0;
}

void actualizar_estadisticas_aritmetica(estadisticas_aritmetica_t* stats, 
                                       resultado_aritmetica_t resultado) {
    if (stats == NULL) {
        return;
    }
    
    switch (resultado) {
        case ARITMETICA_EXITOSA:
            stats->operaciones_exitosas++;
            break;
        case ARITMETICA_OVERFLOW:
            stats->overflows_detectados++;
            break;
        case ARITMETICA_UNDERFLOW:
            stats->underflows_detectados++;
            break;
        case ARITMETICA_DIVISION_CERO:
            stats->divisiones_cero++;
            break;
        case ARITMETICA_ERROR_PARAMETRO:
            stats->errores_parametro++;
            break;
    }
}

void imprimir_estadisticas_aritmetica(const estadisticas_aritmetica_t* stats) {
    if (stats == NULL) {
        return;
    }
    
    size_t total = stats->operaciones_exitosas + stats->overflows_detectados + 
                   stats->underflows_detectados + stats->divisiones_cero + 
                   stats->errores_parametro;
    
    printf("\nüìà Estad√≠sticas de operaciones aritm√©ticas:\n");
    printf("   ‚úÖ Operaciones exitosas: %zu\n", stats->operaciones_exitosas);
    printf("   üî∫ Overflows detectados: %zu\n", stats->overflows_detectados);
    printf("   üîª Underflows detectados: %zu\n", stats->underflows_detectados);
    printf("   ‚ûó Divisiones por cero: %zu\n", stats->divisiones_cero);
    printf("   ‚ùå Errores de par√°metro: %zu\n", stats->errores_parametro);
    printf("   üìä Total de operaciones: %zu\n", total);
    
    if (total > 0) {
        double porcentaje_exitoso = (double)stats->operaciones_exitosas / total * 100.0;
        printf("   üìà Tasa de √©xito: %.1f%%\n", porcentaje_exitoso);
    }
}

void imprimir_limites_tipos_datos(void) {
    printf("\nüìä L√çMITES DE TIPOS DE DATOS:\n");
    printf("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n");
    printf("‚îÇ Tipo            ‚îÇ M√≠nimo              ‚îÇ M√°ximo              ‚îÇ\n");
    printf("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n");
    printf("‚îÇ int             ‚îÇ %20d ‚îÇ %20d ‚îÇ\n", INT_MIN, INT_MAX);
    printf("‚îÇ unsigned int    ‚îÇ %20u ‚îÇ %20u ‚îÇ\n", 0U, UINT_MAX);
    printf("‚îÇ long long       ‚îÇ %20lld ‚îÇ %20lld ‚îÇ\n", LLONG_MIN, LLONG_MAX);
    printf("‚îÇ size_t          ‚îÇ %20zu ‚îÇ %20zu ‚îÇ\n", (size_t)0, SIZE_MAX);
    printf("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
}

void calcular_distancia_limites(int valor, int* distancia_max, int* distancia_min) {
    if (distancia_max) {
        *distancia_max = INT_MAX - valor;
    }
    if (distancia_min) {
        *distancia_min = valor - INT_MIN;
    }
}
