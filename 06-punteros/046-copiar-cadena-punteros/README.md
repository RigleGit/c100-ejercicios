# Ejercicio 046: Copiar Cadena con Punteros

## üìã Descripci√≥n

Este ejercicio explora la copia de cadenas de caracteres utilizando punteros en C, implementando una versi√≥n manual de la funci√≥n `strcpy` de la biblioteca est√°ndar. Es fundamental para entender el manejo de cadenas, la aritm√©tica de punteros y la gesti√≥n de memoria.

## üéØ Objetivo

Implementar diferentes m√©todos para copiar cadenas de caracteres utilizando punteros, demostrando el manejo correcto de arrays de caracteres terminados en `'\0'` y la importancia de la gesti√≥n segura de memoria.

## üìù Enunciado

**Copia de Cadenas con Punteros:**

Crear una funci√≥n que copie una cadena de caracteres (char *orig) en otra (char *dest) sin usar la funci√≥n strcpy de la biblioteca est√°ndar. La funci√≥n debe:

1. Recibir como par√°metros un puntero destino y un puntero origen
2. Copiar todos los caracteres desde origen hasta encontrar `'\0'`
3. Incluir el terminador nulo en la copia
4. Manejar casos especiales como cadenas vac√≠as

**Ejemplo:**
```c
char origen[] = "Hola, mundo!";
char destino[50]; // Asegurarse de que hay suficiente espacio
copiarCadena(destino, origen);
printf("Cadena copiada: %s\n", destino);
```

**Salida esperada:**
```
Cadena copiada: Hola, mundo!
```

## üîß Funciones Implementadas

### Funciones Principales

1. **`copiarCadena(char *dest, const char *orig)`**
   - Implementaci√≥n b√°sica y clara del algoritmo
   - Copia car√°cter por car√°cter usando punteros

2. **`copiarCadena_optimizada(char *dest, const char *orig)`**
   - Versi√≥n optimizada con operaciones combinadas
   - Demuestra expresiones compactas de C

3. **`copiarCadena_retorno(char *dest, const char *orig)`**
   - Versi√≥n que retorna el puntero destino
   - Compatible con el comportamiento de `strcpy`

4. **`copiarCadena_segura(char *dest, const char *orig, size_t tama√±o_max)`**
   - Versi√≥n segura con l√≠mite de buffer
   - Previene desbordamientos de buffer
   - Similar a `strncpy` pero m√°s segura

### Funciones Especializadas

5. **`copiarCadena_overlap(char *dest, const char *orig)`**
   - Maneja casos de solapamiento de memoria
   - Similar a `memmove` para cadenas

6. **`copiarSubcadena(char *dest, const char *orig, size_t inicio, size_t longitud)`**
   - Copia una porci√≥n espec√≠fica de la cadena
   - √ötil para extraer subcadenas

7. **`concatenarCadena(char *dest, const char *orig)`**
   - Concatena cadenas usando punteros
   - Implementaci√≥n manual de `strcat`

### Funciones Auxiliares

8. **`longitudCadena(const char *str)`**
   - Calcula longitud usando aritm√©tica de punteros
   - Implementaci√≥n manual de `strlen`

9. **`invertirCadena(char *str)`**
   - Invierte cadena in-place usando punteros
   - Demuestra manipulaci√≥n bidireccional

10. **`copiarCadena_debug(char *dest, const char *orig)`**
    - Versi√≥n educativa con informaci√≥n paso a paso
    - Muestra direcciones de memoria y proceso

## üèóÔ∏è Estructura del Proyecto

```
046-copiar-cadena-punteros/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ main.c              # Implementaci√≥n principal
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ test_main.c         # Suite de tests con Criterion
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ .gitkeep           # Directorio para headers
‚îú‚îÄ‚îÄ CMakeLists.txt         # Configuraci√≥n de build
‚îú‚îÄ‚îÄ README.md              # Este archivo
‚îî‚îÄ‚îÄ .gitignore            # Archivos a ignorar por git
```

## üß™ Casos de Prueba

### Tests B√°sicos
- ‚úÖ Cadena simple
- ‚úÖ Cadena vac√≠a
- ‚úÖ Un car√°cter
- ‚úÖ Cadena larga
- ‚úÖ Cadenas con espacios
- ‚úÖ Caracteres especiales
- ‚úÖ N√∫meros y letras

### Tests de Funciones Optimizadas
- ‚úÖ Versi√≥n optimizada vs b√°sica
- ‚úÖ Funci√≥n con retorno
- ‚úÖ Encadenamiento de funciones

### Tests de Seguridad
- ‚úÖ Funci√≥n segura con l√≠mites
- ‚úÖ Truncamiento de cadenas largas
- ‚úÖ Buffer de un car√°cter
- ‚úÖ Tama√±o cero
- ‚úÖ Punteros nulos

### Tests de Funciones Auxiliares
- ‚úÖ Copia de subcadenas
- ‚úÖ Concatenaci√≥n de cadenas
- ‚úÖ C√°lculo de longitud
- ‚úÖ Inversi√≥n de cadenas

### Tests de Casos Especiales
- ‚úÖ Caracteres Unicode b√°sicos
- ‚úÖ Saltos de l√≠nea y tabs
- ‚úÖ Caracteres de control

### Tests de Rendimiento
- ‚úÖ Cadenas muy largas
- ‚úÖ Comparaci√≥n entre m√©todos
- ‚úÖ M√∫ltiples operaciones

### Tests de Integraci√≥n
- ‚úÖ Flujo completo de operaciones
- ‚úÖ Operaciones encadenadas
- ‚úÖ Comparaci√≥n con stdlib

## üöÄ Compilaci√≥n y Ejecuci√≥n

### Prerrequisitos
- CMake 3.15 o superior
- Compilador GCC o Clang
- Criterion (para tests)

### Instalaci√≥n de Dependencias

**macOS:**
```bash
brew install cmake criterion
```

**Ubuntu/Debian:**
```bash
sudo apt-get update
sudo apt-get install cmake libcriterion-dev
```

### Compilaci√≥n

```bash
# Crear directorio build
mkdir build && cd build

# Configurar proyecto
cmake ..

# Compilar
make
```

### Ejecuci√≥n

```bash
# Ejecutar programa principal
./main

# Ejecutar tests
make test_all
# o directamente
./test_runner
```

### Targets Disponibles

```bash
make main          # Compilar solo el ejecutable principal
make test_runner    # Compilar solo los tests
make run           # Compilar y ejecutar el programa principal
make test_all      # Ejecutar todos los tests
make clean_all     # Limpieza completa
```

## üìä Ejemplo de Salida

```
=== COPIA DE CADENAS CON PUNTEROS ===

üîπ EJEMPLO B√ÅSICO:
Cadena original: "Hola, mundo!"
Cadena copiada: "Hola, mundo!"

üîπ COPIA DETALLADA:
=== Copia de Cadena Paso a Paso ===
Origen: "C Programming" (direcci√≥n: 0x7fff5fbff6a0)
Destino inicial: 0x7fff5fbff650

Paso 1: copiando 'C' de 0x7fff5fbff6a0 a 0x7fff5fbff650
Paso 2: copiando ' ' de 0x7fff5fbff6a1 a 0x7fff5fbff651
Paso 3: copiando 'P' de 0x7fff5fbff6a2 a 0x7fff5fbff652
...
Paso 13: copiando 'g' de 0x7fff5fbff6ac a 0x7fff5fbff65c
Paso 14: copiando terminador '\0'

Resultado: "C Programming"
Caracteres copiados: 13
===================================

üîπ VERSI√ìN SEGURA CON L√çMITES:
Cadena original: "Esta es una cadena muy larga que podr√≠a desbordar"
Cadena truncada: "Esta es una cad"
Caracteres copiados: 19

üîπ FUNCIONES AUXILIARES:
Texto original: "Programaci√≥n en C"
Subcadena (pos 13, len 5): "en C"
Concatenaci√≥n: "Hola " + "mundo!" = "Hola mundo!"
Longitud de "Medir longitud": 14 caracteres
Original: "abcdef"
Invertida: "fedcba"

üîπ INFORMACI√ìN T√âCNICA:
Tama√±o de char*: 8 bytes
Tama√±o de char: 1 byte
Direcci√≥n de array 'demo': 0x7fff5fbff6bc
Direcci√≥n de demo[0]: 0x7fff5fbff6bc
¬øSon iguales? S√≠
demo + 1 apunta a: 'e' (direcci√≥n: 0x7fff5fbff6bd)
*(demo + 2) = 'm'
```

## üîç Conceptos Clave

### 1. **Arrays vs Punteros en Cadenas**
- `char str[]` vs `char *str`
- Equivalencia entre `str[i]` y `*(str + i)`
- Aritm√©tica de punteros con caracteres

### 2. **Terminador Nulo**
- Todas las cadenas en C terminan en `'\0'`
- Cr√≠tico para determinar el final de la cadena
- Debe incluirse en cualquier copia

### 3. **Algoritmo B√°sico de Copia**
```c
while (*orig != '\0') {
    *dest = *orig;
    dest++;
    orig++;
}
*dest = '\0';
```

### 4. **Versi√≥n Optimizada**
```c
while ((*dest++ = *orig++) != '\0') {
    // Cuerpo vac√≠o
}
```

### 5. **Gesti√≥n Segura de Memoria**
- Verificar tama√±o del buffer destino
- Validar punteros nulos
- Prevenir desbordamientos de buffer

### 6. **Const Correctness**
- Usar `const char *` para par√°metros de solo lectura
- Evitar modificaciones accidentales del origen

## ‚ö†Ô∏è Consideraciones Importantes

### Seguridad
- **Buffer Overflow**: Verificar que destino sea suficientemente grande
- **Punteros Nulos**: Validar par√°metros antes de usar
- **L√≠mites**: Usar versiones seguras con l√≠mite de tama√±o
- **Solapamiento**: Considerar casos donde origen y destino se solapan

### Rendimiento
- Versi√≥n optimizada es m√°s eficiente pero menos legible
- Evitar verificaciones innecesarias en bucles cr√≠ticos
- Considerar alineaci√≥n de memoria para cadenas largas

### Portabilidad
- C√≥digo est√°ndar C funciona en todas las plataformas
- Tama√±o de punteros puede variar (32 vs 64 bits)
- Endianness no afecta operaciones de caracteres

## üéì Aplicaciones Pr√°cticas

### 1. **Procesamiento de Texto**
- Parsers y lexers
- Manipulaci√≥n de strings en compiladores
- Procesamiento de archivos de configuraci√≥n

### 2. **Sistemas Embebidos**
- Donde no hay biblioteca est√°ndar disponible
- Control preciso sobre memoria
- Optimizaci√≥n de rendimiento

### 3. **Seguridad**
- Implementaciones seguras de funciones de cadenas
- Validaci√≥n de entrada de usuario
- Prevenci√≥n de vulnerabilidades

### 4. **Educaci√≥n**
- Entender c√≥mo funcionan las funciones est√°ndar
- Desarrollar intuici√≥n sobre punteros
- Base para estructuras de datos m√°s complejas

## üîß Optimizaciones Avanzadas

### 1. **Copia por Palabras**
```c
// Para cadenas muy largas, copiar por bloques de sizeof(long)
while (remaining >= sizeof(long)) {
    *(long*)dest = *(long*)orig;
    dest += sizeof(long);
    orig += sizeof(long);
    remaining -= sizeof(long);
}
```

### 2. **Detecci√≥n de Terminador R√°pida**
```c
// Usar operaciones bit a bit para detectar '\0' r√°pidamente
long word = *(long*)orig;
if ((word - 0x0101010101010101L) & ~word & 0x8080808080808080L) {
    // Hay un byte cero en la palabra
}
```

### 3. **Prefetching**
```c
// En sistemas modernos, prefetch puede mejorar rendimiento
__builtin_prefetch(orig + 64, 0, 3);
```

## üìö Comparaci√≥n con Funciones Est√°ndar

| Funci√≥n Est√°ndar | Nuestra Implementaci√≥n | Ventajas |
|------------------|------------------------|----------|
| `strcpy` | `copiarCadena_retorno` | Educativa, control total |
| `strncpy` | `copiarCadena_segura` | M√°s segura, siempre termina en `\0` |
| `strlen` | `longitudCadena` | Demuestra aritm√©tica de punteros |
| `strcat` | `concatenarCadena` | Implementaci√≥n transparente |
| `memmove` | `copiarCadena_overlap` | Manejo expl√≠cito de solapamiento |

## üîç Debugging y Herramientas

### Valgrind (Linux/macOS)
```bash
valgrind --tool=memcheck --leak-check=full ./main
```

### AddressSanitizer
```bash
gcc -fsanitize=address -g src/main.c -o main
./main
```

### Static Analysis
```bash
clang-tidy src/main.c -- -I./include
```

## ü§ù Contribuci√≥n

Para contribuir a este ejercicio:

1. Fork el repositorio
2. Crea una rama para tu feature
3. A√±ade tests para nuevas funcionalidades
4. Aseg√∫rate de que todos los tests pasen
5. Verifica con herramientas de an√°lisis est√°tico
6. Env√≠a un pull request

## üìÑ Licencia

Este proyecto es parte del curso "100 Ejercicios de C" y est√° disponible bajo la licencia MIT.

## üìö Referencias

- **Kernighan & Ritchie**: "The C Programming Language", Cap√≠tulo 5
- **C11 Standard**: ISO/IEC 9899:2011, Secci√≥n 7.24 (String handling)
- **CERT C Coding Standard**: STR31-C, STR32-C
- **Criterion Documentation**: Testing framework para C
